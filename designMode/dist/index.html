<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>设计模式</title>
    <style>
      * {
        border: 0;
        margin: 0;
        padding: 0;
      }
      body {
        padding: 10px;
      }
      .dm {
        border-collapse: collapse;
        margin-bottom: 6px;
        margin-top: 6px;
      }
      .dm th {
        color: #fff;
        background-color: #555;
        border: 1px solid #555;
        font-size: 13px;
        padding: 3px;
        vertical-align: top;
        text-align: left;
      }
      .dm td {
        line-height: 2em;
        min-width: 24px;
        border: 1px solid #d4d4d4;
        padding: 5px;
        padding-top: 7px;
        padding-bottom: 7px;
        vertical-align: top;
        font-size: 13px;
      }
      .dm ul {
        list-style-type: none;
        margin: 2px;
        display: flex;
        flex-wrap: wrap;
      }
      .dm li {
        width: 50%;
      }
    </style>
  </head>
  <body>
    <div>
      <a href="https://www.runoob.com/design-pattern/design-pattern-tutorial.html" target="_blank">设计模式</a>
    </div>

    <table class="dm">
      <tbody>
        <tr>
          <th style="width: 5%">序号</th>
          <th style="width: 45%">模式 &amp; 描述</th>
          <th>包括</th>
        </tr>
        <tr>
          <td>1</td>
          <td>
            <b>创建型模式</b>
            <br />
            这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new
            运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。
          </td>
          <td>
            <ul>
              <li>工厂模式（Factory Pattern）</li>
              <li>抽象工厂模式（Abstract Factory Pattern）</li>
              <li>单例模式（Singleton Pattern）</li>
              <li>建造者模式（Builder Pattern）</li>
              <li>原型模式（Prototype Pattern）</li>
            </ul>
          </td>
        </tr>
        <tr>
          <td>2</td>
          <td>
            <b>结构型模式</b>
            <br />
            这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。
          </td>
          <td>
            <ul>
              <li>适配器模式（Adapter Pattern）</li>
              <li>桥接模式（Bridge Pattern）</li>
              <li>过滤器模式（Filter、Criteria Pattern）</li>
              <li>组合模式（Composite Pattern）</li>
              <li>装饰器模式（Decorator Pattern）</li>
              <li>外观模式（Facade Pattern）</li>
              <li>享元模式（Flyweight Pattern）</li>
              <li>代理模式（Proxy Pattern）</li>
            </ul>
          </td>
        </tr>
        <tr>
          <td>3</td>
          <td>
            <b>行为型模式</b>
            <br />
            这些设计模式特别关注对象之间的通信。
          </td>
          <td>
            <ul>
              <li>责任链模式（Chain of Responsibility Pattern）</li>
              <li>命令模式（Command Pattern）</li>
              <li>解释器模式（Interpreter Pattern）</li>
              <li>迭代器模式（Iterator Pattern）</li>
              <li>中介者模式（Mediator Pattern）</li>
              <li>备忘录模式（Memento Pattern）</li>
              <li>观察者模式（Observer Pattern）</li>
              <li>状态模式（State Pattern）</li>
              <li>空对象模式（Null Object Pattern）</li>
              <li>策略模式（Strategy Pattern）</li>
              <li>模板模式（Template Pattern）</li>
              <li>访问者模式（Visitor Pattern）</li>
            </ul>
          </td>
        </tr>
        <tr>
          <td>4</td>
          <td>
            <b>J2EE 模式</b>
            <br />
            这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。
          </td>
          <td>
            <ul>
              <li>MVC 模式（MVC Pattern）</li>
              <li>业务代表模式（Business Delegate Pattern）</li>
              <li>组合实体模式（Composite Entity Pattern）</li>
              <li>数据访问对象模式（Data Access Object Pattern）</li>
              <li>前端控制器模式（Front Controller Pattern）</li>
              <li>拦截过滤器模式（Intercepting Filter Pattern）</li>
              <li>服务定位器模式（Service Locator Pattern）</li>
              <li>传输对象模式（Transfer Object Pattern）</li>
            </ul>
          </td>
        </tr>
      </tbody>
    </table>
    <script src="./bundle.js"></script>
  </body>
</html>
