<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>1266. 访问所有点的最小时间</title>
  </head>
  <body>
    <script>
      // https://leetcode.cn/problems/minimum-time-visiting-all-points/

      // 平面上有 n 个点，点的位置用整数坐标表示 points[i] = [xi, yi] 。请你计算访问所有这些点需要的 最小时间（以秒为单位）。
      // 你需要按照下面的规则在平面上移动：
      // 提示：
      // 每一秒内，你可以：
      // 沿水平方向移动一个单位长度，或者
      // 沿竖直方向移动一个单位长度，或者
      // 跨过对角线移动 sqrt(2) 个单位长度（可以看作在一秒内向水平和竖直方向各移动一个单位长度）。
      // 必须按照数组中出现的顺序来访问这些点。
      // 在访问某个点时，可以经过该点后面出现的点，但经过的那些点不算作有效访问。
      // 提示：
      // points.length == n
      // 1 <= n <= 100
      // points[i].length == 2
      // -1000 <= points[i][0], points[i][1] <= 1000

      /**
       * @param {number[][]} points
       * @return {number}
       */
      var minTimeToVisitAllPoints = function (points) {};

      // --- answer-1 ---

      // 相邻两个点的距离的和
      // 斜着走也是一个单位长度，从向量上理解相当于横向 纵向走1
      // 那么两个点的距离实际就是x, y轴上的距离的最大值
      var minTimeToVisitAllPoints = function (points) {
        let result = 0;
        let [x, y] = points[0];
        for (let i = 1; i < points.length; i++) {
          const [x1, y1] = points[i];
          result += Math.max(Math.abs(x - x1), Math.abs(y - y1));
          x = x1;
          y = y1;
        }
        return result;
      };

      // --- answer-1 ---

      // --- answer-2 ---

      // --- answer-2 ---

      var points = [
        [1, 1],
        [3, 4],
        [-1, 0]
      ];
      var result = 7;
      // 解释：一条最佳的访问路径是： [1,1] -> [2,2] -> [3,3] -> [3,4] -> [2,3] -> [1,2] -> [0,1] -> [-1,0]

      var points = [
        [3, 2],
        [-2, 2]
      ];
      var result = 5;

      console.log('points = ', points);
      console.log('result = ', result);
      console.log('minTimeToVisitAllPoints = ', minTimeToVisitAllPoints(points));
    </script>
  </body>
</html>
