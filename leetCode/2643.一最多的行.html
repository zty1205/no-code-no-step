<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>2643. 一最多的行</title>
  </head>
  <body>
    <script>
      // https://leetcode.cn/problems/row-with-maximum-ones/description/

      // 给你一个大小为 m x n 的二进制矩阵 mat ，请你找出包含最多 1 的行的下标（从 0 开始）以及这一行中 1 的数目。
      // 如果有多行包含最多的 1 ，只需要选择 行下标最小 的那一行。
      // 返回一个由行下标和该行中 1 的数量组成的数组。
      //
      // 提示：
      // m == mat.length
      // n == mat[i].length
      // 1 <= m, n <= 100
      // mat[i][j] 为 0 或 1

      /**
       * @param {number[][]} mat
       * @return {number[]}
       */
      var rowAndMaximumOnes = function (mat) {};

      // --- answer-1 ---

      // 遍历即可
      var rowAndMaximumOnes = function (mat = [[]]) {
        let count = 0;
        let idx = 0;
        mat.forEach((arr, i) => {
          // 因为只有0 1 求和也可以
          let cnt = arr.filter((x) => x === 1).length;
          if (cnt > count) {
            count = cnt;
            idx = i;
          }
        });
        return [idx, count];
      };

      // --- answer-1 ---

      // --- answer-2 ---

      // --- answer-2 ---

      var mat = [
        [0, 1],
        [1, 0]
      ];
      var result = [0, 1];
      // 解释：两行中 1 的数量相同。所以返回下标最小的行，下标为 0 。该行 1 的数量为 1 。所以，答案为 [0,1] 。

      var mat = [
        [0, 0, 0],
        [0, 1, 1]
      ];
      var result = [1, 2];
      // 解释：下标为 1 的行中 1 的数量最多。该行 1 的数量为 2 。所以，答案为 [1,2] 。

      var mat = [
        [0, 0],
        [1, 1],
        [0, 0]
      ];
      var result = [1, 2];
      // 解释：下标为 1 的行中 1 的数量最多。该行 1 的数量为 2 。所以，答案为 [1,2] 。

      console.log('mat = ', mat);
      console.log('result = ', result);
      console.log('rowAndMaximumOnes = ', rowAndMaximumOnes(mat));
    </script>
  </body>
</html>
