<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>733. 图像渲染</title>
  </head>
  <body>
    <script>
      // https://leetcode.cn/problems/flood-fill/

      // 有一幅以 m x n 的二维整数数组表示的图画 image ，其中 image[i][j] 表示该图画的像素值大小。
      // 你也被给予三个整数 sr ,  sc 和 newColor 。你应该从像素 image[sr][sc] 开始对图像进行 上色填充 。
      // 为了完成 上色工作 ，从初始像素开始，记录初始坐标的 上下左右四个方向上 像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应 四个方向上 像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为 newColor 。
      // 最后返回 经过上色渲染后的图像 。
      // 提示：
      // m == image.length
      // n == image[i].length
      // 1 <= m, n <= 50
      // 0 <= image[i][j], newColor < 216
      // 0 <= sr < m
      // 0 <= sc < n

      /**
       * @param {number[][]} image
       * @param {number} sr
       * @param {number} sc
       * @param {number} color
       * @return {number[][]}
       */
      var floodFill = function (image, sr, sc, color) {};

      // --- answer-1 ---

      // 深度遍历
      // visited 对于重复访问的直接return
      var floodFill = function (image = [[]], sr, sc, color) {
        const m = image.length;
        const n = image[0].length;
        const visited = Array.from({ length: m }, () => new Array(n).fill(false));
        function fill(r, c, old, newC) {
          if (r < 0 || r > m - 1) return;
          if (c < 0 || c > n - 1) return;
          if (old === newC) return; // 颜色值一样的就不用更改了
          if (visited[r][c]) return;
          visited[r][c] = true;
          if (image[r][c] === old) {
            image[r][c] = newC;
            fill(r - 1, c, old, newC);
            fill(r + 1, c, old, newC);
            fill(r, c + 1, old, newC);
            fill(r, c - 1, old, newC);
          }
        }
        fill(sr, sc, image[sr][sc], color);
        return image;
      };

      // --- answer-1 ---

      // --- answer-2 ---

      // --- answer-2 ---

      var image = [
          [1, 1, 1],
          [1, 1, 0],
          [1, 0, 1]
        ],
        sr = 1,
        sc = 1,
        newColor = 2;
      var result = [
        [2, 2, 2],
        [2, 2, 0],
        [2, 0, 1]
      ];
      // 解析: 在图像的正中间，(坐标(sr,sc)=(1,1)),在路径上所有符合条件的像素点的颜色都被更改成2。

      var image = [
          [0, 0, 0],
          [0, 0, 0]
        ],
        sr = 0,
        sc = 0,
        newColor = 2;
      var result = [
        [2, 2, 2],
        [2, 2, 2]
      ];

      var image = [
          [0, 0, 0],
          [0, 0, 0]
        ],
        sr = 0,
        sc = 0,
        newColor = 0;
      var result = [
        [0, 0, 0],
        [0, 0, 0]
      ];

      console.log('image = ', image);
      console.log('sr = ', sr);
      console.log('sc = ', sc);
      console.log('color = ', newColor);
      console.log('result = ', result);
      console.log('floodFill = ', floodFill(image, sr, sc, newColor));
    </script>
  </body>
</html>
