<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      /* 1 */

      // 在一个二维数组中（每个一维数组的长度相同），
      // 每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。
      // 请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数

      /* 2 */

      // 请实现一个函数，将一个字符串中的每个空格替换成“%20”。
      // 例如，当字符串为We Are Happy.
      // 则经过替换之后的字符串为We%20Are%20Happy。

      /* 3 */

      // 输入一个链表，按链表从尾到头的顺序返回一个ArrayList。

      /* 4 */

      // 输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。
      // 假设输入的前序遍历和中序遍历的结果中都不含重复的数字。
      // 例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。

      /* 5 */

      // 用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。

      /* 6 */

      // 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。
      // 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。
      // NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。

      /* 7 */

      // 大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项
      //（从0开始，第0项为0，第1项是1）。

      /* 8 */

      // 一只青蛙一次可以跳上1级台阶，也可以跳上2级。
      // 求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。

      /* 9 */

      // 一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。
      // 求该青蛙跳上一个n级的台阶总共有多少种跳法。

      /* 10 */

      // 我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。
      // 请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？
      // 比如n=3时，2*3的矩形块有3种覆盖方法：

      /* 11 */

      // 输入一个整数，输出该数32位二进制表示中1的个数。其中负数用补码表示。

      /* 12 */

      // 给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。
      // 保证base和exponent不同时为0

      /* 13 */

      // 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，
      // 使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，
      // 并保证奇数和奇数，偶数和偶数之间的相对位置不变。
      // 考虑原地算法

      /* 14 */

      // 输入一个链表，输出该链表中倒数第k个结点。

      /* 15 */

      // 输入一个链表，反转链表后，输出新链表的表头。

      /* 16 */

      // 输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。

      /* 17 */

      // 输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）
      // 注意这里是子结构而不是子树

      /* 18 */

      // 操作给定的二叉树，将其变换为源二叉树的镜像。

      /* 19 */

      // 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，
      // 例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16
      // 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.

      /* 20 */
      // 定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。

      /* 21 */

      // 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。
      // 假设压入栈的所有数字均不相等。
      // 例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，
      // 但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）

      /* 22 */

      // 从上往下打印出二叉树的每个节点，同层节点从左至右打印。

      /* 23 */

      // 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。
      // 如果是则返回true,否则返回false。
      // 假设输入的数组的任意两个数字都互不相同。

      /* 24 */

      // 输入一颗二叉树的根节点和一个整数，按字典序打印出二叉树中结点值的和为输入整数的所有路径。
      // 路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。

      /* 25 */

      // 输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针random指向一个随机节点），
      // 请对此链表进行深拷贝，并返回拷贝后的头结点。
      //（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）

      /* 26 */

      // 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。

      /* 27 */

      // 输入一个字符串,按字典序打印出该字符串中字符的所有排列。
      // 例如输入字符串abc,则按字典序打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。

      /* 28 */

      // 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。
      // 例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。
      // 由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。

      /* 29 */

      // 给定一个数组，找出其中最小的K个数。
      // 例如数组元素是4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4。
      // 如果K>数组的长度，那么返回一个空的数组

      /* 30 */

      // 输入一个整型数组，数组里有正数也有负数。
      // 数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。
      // 要求时间复杂度为 O(n).

      /* 31 */

      // 求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？
      // 为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。
      // ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。

      /* 32 */

      // 输入一个正整数数组，把数组里所有数字拼接起来排成一个数，
      // 打印能拼接出的所有数字中最小的一个。
      // 例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。

      /* 33 */

      // 把只包含质因子2、3和5的数称作丑数（Ugly Number）。
      // 例如6、8都是丑数，但14不是，因为它包含质因子7。
      // 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。

      /* 34 */

      // 在一个字符串(0<=字符串长度<=10000，全部由字母组成)
      // 中找到第一个只出现一次的字符,并返回它的位置,
      // 如果没有则返回 -1（需要区分大小写）.（从0开始计数）

      /* 35 */
      // 没怎么理解

      // 在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。
      // 输入一个数组,求出这个数组中的逆序对的总数P。
      // 并将P对1000000007取模的结果输出。 即输出P%1000000007

      /* 36 */

      // 输入两个链表，找出它们的第一个公共结点。
      //（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）

      /* 37 */

      // 统计一个数字在升序数组中出现的次数。

      /* 38 */

      // 输入一棵二叉树，求该树的深度。
      // 从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，
      // 最长路径的长度为树的深度。

      /* 39 */

      // 输入一棵二叉树，判断该二叉树是否是平衡二叉树。
      // 在这里，我们只需要考虑其平衡性，不需要考虑其是不是排序二叉树
      // 平衡二叉树（Balanced Binary Tree），
      // 具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，
      // 并且左右两个子树都是一棵平衡二叉树。

      /* 40 */

      // 一个整型数组里除了两个数字之外，其他的数字都出现了两次。
      // 请写程序找出这两个只出现一次的数字。

      /* 41 */

      // 小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。
      // 但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。
      // 没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。
      // 现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!
      // 输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序

      /* 42 */

      // 输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。
      // 对应每个测试案例，输出两个数，小的先输出。

      /* 43 */

      // 汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。
      // 对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。
      // 例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！

      /* 44 */

      // 牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。
      // 同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。
      // 例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，
      // 正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？

      /* 45 */

      // LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)...
      // 他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！
      // “红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子.....LL不高兴了,
      // 他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。
      // 上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。
      // LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何，
      // 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。

      /* 46 */

      // 每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,
      // 今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。
      // 其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。
      // 然后,他随机指定一个数m,让编号为0的小朋友开始报数。
      // 每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,
      // 从他的下一个小朋友开始,继续0...m-1报数....这样下去....直到剩下最后一个小朋友,
      // 可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。
      // 请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)
      // 如果没有小朋友，请返回-1

      /* 47 */

      // 求1+2+3+...+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。

      /* 48 */

      // 写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。

      /* 49 */

      // 将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。
      // 数值为0或者字符串不是一个合法的数值则返回0
      // 输入描述:
      // 输入一个字符串,包括数字字母符号,可以为空
      // 返回值描述:
      // 如果是合法的数值表达则返回该数字，否则返回0

      /* 50 */

      // 在一个长度为n的数组里的所有数字都在0到n-1的范围内。
      // 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。
      // 请找出数组中第一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。
      // 返回描述：
      // 如果数组中有重复的数字，函数返回true，否则返回false。
      // 如果数组中有重复的数字，把重复的数字放到参数duplication[0]中。（ps:duplication已经初始化，可以直接赋值使用。）

      /* 52 */

      // 请实现一个函数用来匹配包括'.'和'*'的正则表达式。
      // 模式中的字符'.'表示任意一个字符，而'*'表示它前面的字符可以出现任意次（包含0次）。
      // 在本题中，匹配是指字符串的所有字符匹配整个模式。
      // 例如，字符串"aaa"与模式"a.a"和"ab*ac*a"匹配，但是与"aa.a"和"ab*a"均不匹配

      /* 53 */

      // 请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。
      // 例如，字符串"+100","5e2","-123","3.1416"和"-1E-16"都表示数值。
      // 但是"12e","1a3.14","1.2.3","+-5"和"12e+4.3"都不是。

      /* 54 */

      // 请实现一个函数用来找出字符流中第一个只出现一次的字符。
      // 例如，当从字符流中只读出前两个字符"go"时，第一个只出现一次的字符是"g"。
      // 当从该字符流中读出前六个字符“google"时，第一个只出现一次的字符是"l"。
      // 如果当前字符流没有存在出现一次的字符，返回#字符。

      /* 55 */

      // 给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。

      /* 56 */

      // 在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。
      // 例如，链表1->2->3->3->4->4->5 处理后为 1->2->5
      // 如果是 1->2->3->2->4 处理后为 1->3->4 哦 不用考虑 这是一个排序的链表 那需要两个指针
      // 如果头节点就重复呢

      /* 57 */

      // 给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。
      // 注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针

      /* 58 */

      // 请实现一个函数，用来判断一棵二叉树是不是对称的。
      // 注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。

      /* 59 */

      // 请实现一个函数按照之字形打印二叉树，
      // 即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，
      // 其他行以此类推。

      /* 60 */

      // 从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。

      /* 61 */

      // 请实现两个函数，分别用来序列化和反序列化二叉树
      // 二叉树的序列化是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。
      // 序列化可以基于先序、中序、后序、层序的二叉树遍历方式来进行修改，序列化的结果是一个字符串，
      // 序列化时通过 某种符号表示空节点（#），以 ！ 表示一个结点值的结束（value!）。
      // 二叉树的反序列化是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。
      // 例如，我们可以把一个只有根节点为1的二叉树序列化为"1,"，然后通过自己的函数来解析回这个二叉树

      /* 62 */

      // 给定一棵二叉搜索树，请找出其中的第k小的结点。

      /* 63 */

      // 如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。
      // 如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。
      // 我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。

      /* 64 */

      // 给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。
      // 例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，
      // 他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个：
      // {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}，
      // {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。
      // 窗口大于数组长度的时候，返回空

      /* 65 */
      // 回溯不太会

      // 请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。
      // 路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。
      // 如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如
      //  | a b c e |
      //  | s f c s |
      //  | a d e e |
      // 矩阵中包含一条字符串"bcced"的路径，但是矩阵中不包含"abcb"路径，
      // 因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子

      /* 66 */

      // 地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，
      // 但是不能进入行坐标和列坐标的数位之和大于k的格子。
      // 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。
      // 但是，它不能进入方格（35,38），因为3+5+3+8 = 19。
      // 请问该机器人能够达到多少个格子？

      /* 67 */
      // 数学 + 动态 不太懂

      // 给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n>1并且m>1，m<=n），
      // 每段绳子的长度记为k[1],...,k[m]。请问k[1]x...xk[m]可能的最大乘积是多少？
      // 例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。
    </script>
  </body>
</html>
